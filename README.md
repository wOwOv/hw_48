락프리큐

에러
1. Dequeue함수에서 <예외가 throw됨: 읽기 액세스 위반입니다.
datanode이(가) nullptr였습니다.>
ㄴ이때 조사식으로 size확인하니 7이었음...그럼 예외 발생시키는 동안 다른 스레드들이 넣은건가...
ㄴdatanode가 nullptr이었다는건...큐에 아무것도 없었다....
A. 뽑아서 건네줄 노드가 nullptr이었다면 return false하기..

2.애초에 5개 인큐 후 5개 디큐하기에 디큐하려고할때 큐가 비어있을 수 없음
그런데 디큐시에 false 리턴하는 경우가 생김
=>c8 12 44 dc 1e 02 71 53노드를 접근하여 이 노드의 next의 data를 뽑아가려고했음.
하지만 그 사이 노드는 이미 다른 스레드가 뽑아가고 메모리풀로 반환되었고 다시 할당되어 tail로 들어가 next가 nullptr을 가리키고 있음.
그래서 큐 사이즈가 0이 아닌데도 데이터 뽑으려는 노드의 next가 nullptr이라 없다고 생각하고 return false한 것..

A? nullptr인지 비교하는게 문제인가..
그냥 nullptr이면 계속 될때까지 빙글빙글 돌리면 저 문제 안 나올 것 같은데..
A.size 한번 확인해서 비어있던 게 아니라면 돌리자

3. 너무 잘 돌아가길래 중지 눌러보니까 모든 스레드가 인큐 함수 안에서 돌고있음
모든 스레드가 인큐 행위를 못해서 못 벗어나고 있음
1.3810스레드가 tail을 c8 2f b0 06 94 01 e1 36로 저장해두고 퀀텀 내려갔음
2.이후 d83b가 인큐하고 tail을 c8 2f b0 06 94 01 46 37로 변경함.
3.3810이 다시 running되고 tail의 태그를 떼고 포인터의 next가 nullptr이라서 자신이 생성한 노드를 연결했음. 하지만 tail의 풀포인터를 비교하니 현재 포인터와는 달라서 tail을 바꿔주지는 않음
4. 이후 스레드들이 인큐를 시도하지만 tail의 next는 nullptr이 아니라 빙글빙글 돌고있음
=>tail의 포인터를 비교하는게 아닌 tail의 next를 비교하는 것이다보니 tail 자체는 다르지만 연결 되는 경우가 있어서 발생하는 상황

ㄴ노드들이 태그를 들고 있어서 생기는것이기도 하지 않나..?
ㄴ원장님이 말씀하신대로 head만 tag를 갖도록 할까
ㄴ원장님이 말씀하신대로 head만 tag를 갖도록 해도 head와 tail이 모두 더미노드를 가리킬 때 같은 상황이 발생할 수 있음.

A?.연결은 성공했지만 저장하고 있던 oldtail과 현재 tail이 달라서 tail 변경을 실패했다면..그냥 나로 tail을 바꾸자
		if (curtail != (__int64)oldtail)
		{
			InterlockedCompareExchange64((__int64*)&_tail, (_int64)countnode, (__int64)_tail);
		}

아니면 추가로 내 노드의 next가 nullptr인지 확인하고 바꿔주기..?

3A.oldtail을 가져와서 next가 nullptr이 아니면 내가 oldtail의 next를 head로 바꾸고 다시 수행하자
_____________________________________해결


(4.디큐하는 스레드3개는 oldhead의 next가 null을 가리키고 있어서 빠져나오질 못하고 있음/인큐하는 스레드1개는 tail의 next가 null이 아니라서 빙글빙글 돌고 있음)

